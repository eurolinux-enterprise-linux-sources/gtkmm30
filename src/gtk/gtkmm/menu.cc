// Generated by gmmproc 2.50.0 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gtkmm/menu.h>
#include <gtkmm/private/menu_p.h>


/* Copyright 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <gtk/gtk.h>
#include <gtkmm/accelgroup.h>


static void SignalProxy_PopupPosition_gtk_callback(GtkMenu*, int* x, int* y, gboolean* push_in, void* data)
{
  auto the_slot = static_cast<Gtk::Menu::SlotPositionCalc*>(data);

  int  temp_x = (x) ? *x : 0;
  int  temp_y = (y) ? *y : 0;
  bool temp_push_in = (push_in) ? bool(*push_in) : false;

  try
  {
    (*the_slot)(temp_x, temp_y, temp_push_in);
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
  }

  if(x) *x = temp_x;
  if(y) *y = temp_y;
  if(push_in) *push_in = temp_push_in;
}

static void SignalProxy_PopupPosition_gtk_callback_destroy(void* data)
{
  auto the_slot = static_cast<Gtk::Menu::SlotPositionCalc*>(data);
  delete the_slot;
}


namespace Gtk
{

Menu::Menu(const Glib::RefPtr<Gio::MenuModel>& model)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Gtk::MenuShell(Glib::ConstructParams(menu_class_.init()))
{
  //g_return_val_if_fail (G_IS_MENU_MODEL (model), NULL);

  bind_model(model, true);
}

void Menu::popup(const SlotPositionCalc& position_calc_slot, guint button, guint32 activate_time, const Glib::RefPtr<Gdk::Device>& device)
{
  // Tell GTK+ to call the static function with the slot's address as the extra
  // data, so that the static function can then call the sigc::slot:
  if(!device)
    gtk_menu_popup(gobj(), nullptr, nullptr, &SignalProxy_PopupPosition_gtk_callback, const_cast<SlotPositionCalc*>(&position_calc_slot), button, activate_time);
  else
  {
    auto slot_copy = new SlotPositionCalc(position_calc_slot); //Deleted in the destroy callback.

    gtk_menu_popup_for_device(gobj(), device->gobj(), nullptr, nullptr, &SignalProxy_PopupPosition_gtk_callback, slot_copy, &SignalProxy_PopupPosition_gtk_callback_destroy, button, activate_time);
  }
}

void Menu::popup(MenuShell& parent_menu_shell, MenuItem& parent_menu_item, const SlotPositionCalc& position_calc_slot, guint button, guint32 activate_time, const Glib::RefPtr<Gdk::Device>& device)
{
  // Tell GTK+ to call the static function with the slot's address as the extra
  // data, so that the static function can then call the sigc::slot:
  if(!device)
    gtk_menu_popup(gobj(), parent_menu_shell.Gtk::Widget::gobj(), parent_menu_item.Gtk::Widget::gobj(), &SignalProxy_PopupPosition_gtk_callback, const_cast<SlotPositionCalc*>(&position_calc_slot), button, activate_time);
  else
  {
    auto slot_copy = new SlotPositionCalc(position_calc_slot); //Deleted in the destroy callback.

    gtk_menu_popup_for_device(gobj(), device->gobj(), parent_menu_shell.Gtk::Widget::gobj(), parent_menu_item.Gtk::Widget::gobj(), &SignalProxy_PopupPosition_gtk_callback, slot_copy, &SignalProxy_PopupPosition_gtk_callback_destroy, button, activate_time);
  }
}

void Menu::popup(guint button, guint32 activate_time, const Glib::RefPtr<Gdk::Device>& device)
{
  if(!device)
    gtk_menu_popup(gobj(), nullptr, nullptr, nullptr, nullptr, button, activate_time);
  else
    gtk_menu_popup_for_device(gobj(), device->gobj(), nullptr, nullptr, nullptr, nullptr, nullptr, button, activate_time);
}

void Menu::reorder_child(const MenuItem& child, int position)
{
  gtk_menu_reorder_child(
      gobj(),
      const_cast<GtkWidget*>(child.Gtk::Widget::gobj()),
      position);
}

void Menu::unset_accel_group()
{
  gtk_menu_set_accel_group(gobj(), nullptr);
}

#ifndef GTKMM_DISABLE_DEPRECATED

G_GNUC_BEGIN_IGNORE_DEPRECATIONS
void Menu::unset_title()
{
  gtk_menu_set_title(gobj(), nullptr);
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GTKMM_DISABLE_DEPRECATED


void Menu::attach_to_widget(Widget& attach_widget)
{
  gtk_menu_attach_to_widget(gobj(), (attach_widget).gobj(), nullptr /* allowed by the C docs. */);
}


} // namespace Gtk

namespace
{


static void Menu_signal_popped_up_callback(GtkMenu* self, gpointer p0,gpointer p1,gboolean p2,gboolean p3,void* data)
{
  using namespace Gtk;
  using SlotType = sigc::slot< void,const Gdk::Rectangle*,const Gdk::Rectangle*,bool,bool >;

  auto obj = dynamic_cast<Menu*>(Glib::ObjectBase::_get_current_wrapper((GObject*) self));
  // Do not try to call a signal on a disassociated wrapper.
  if(obj)
  {
    try
    {
      if(const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(&Glib::wrap((GdkRectangle*)p0)
, &Glib::wrap((GdkRectangle*)p1)
, p2
, p3
);
    }
    catch(...)
    {
       Glib::exception_handlers_invoke();
    }
  }
}

static const Glib::SignalProxyInfo Menu_signal_popped_up_info =
{
  "popped-up",
  (GCallback) &Menu_signal_popped_up_callback,
  (GCallback) &Menu_signal_popped_up_callback
};


} // anonymous namespace


namespace Glib
{

Gtk::Menu* wrap(GtkMenu* object, bool take_copy)
{
  return dynamic_cast<Gtk::Menu *> (Glib::wrap_auto ((GObject*)(object), take_copy));
}

} /* namespace Glib */

namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& Menu_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Menu_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gtk_menu_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void Menu_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* Menu_Class::wrap_new(GObject* o)
{
  return manage(new Menu((GtkMenu*)(o)));

}


/* The implementation: */

Menu::Menu(const Glib::ConstructParams& construct_params)
:
  Gtk::MenuShell(construct_params)
{
  }

Menu::Menu(GtkMenu* castitem)
:
  Gtk::MenuShell((GtkMenuShell*)(castitem))
{
  }


Menu::Menu(Menu&& src) noexcept
: Gtk::MenuShell(std::move(src))
{}

Menu& Menu::operator=(Menu&& src) noexcept
{
  Gtk::MenuShell::operator=(std::move(src));
  return *this;
}

Menu::~Menu() noexcept
{
  destroy_();
}

Menu::CppClassType Menu::menu_class_; // initialize static member

GType Menu::get_type()
{
  return menu_class_.init().get_type();
}


GType Menu::get_base_type()
{
  return gtk_menu_get_type();
}


Menu::Menu()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Gtk::MenuShell(Glib::ConstructParams(menu_class_.init()))
{
  

}

void Menu::popup_at_rect(const Glib::RefPtr<Gdk::Window>& rect_window, const Gdk::Rectangle& rect, Gdk::Gravity rect_anchor, Gdk::Gravity menu_anchor, const GdkEvent* trigger_event)
{
  gtk_menu_popup_at_rect(gobj(), Glib::unwrap(rect_window), (rect).gobj(), ((GdkGravity)(rect_anchor)), ((GdkGravity)(menu_anchor)), trigger_event);
}

void Menu::popup_at_widget(Widget* widget, Gdk::Gravity widget_anchor, Gdk::Gravity menu_anchor, const GdkEvent* trigger_event)
{
  gtk_menu_popup_at_widget(gobj(), (GtkWidget*)Glib::unwrap(widget), ((GdkGravity)(widget_anchor)), ((GdkGravity)(menu_anchor)), trigger_event);
}

void Menu::popup_at_pointer(const GdkEvent* trigger_event)
{
  gtk_menu_popup_at_pointer(gobj(), trigger_event);
}

void Menu::reposition()
{
  gtk_menu_reposition(gobj());
}

void Menu::popdown()
{
  gtk_menu_popdown(gobj());
}

MenuItem* Menu::get_active()
{
  return Glib::wrap((GtkMenuItem*)(gtk_menu_get_active(gobj())));
}

const MenuItem* Menu::get_active() const
{
  return const_cast<Menu*>(this)->get_active();
}

void Menu::set_active(guint index)
{
  gtk_menu_set_active(gobj(), index);
}

void Menu::set_accel_group(const Glib::RefPtr<AccelGroup>& accel_group)
{
  gtk_menu_set_accel_group(gobj(), Glib::unwrap(accel_group));
}

Glib::RefPtr<AccelGroup> Menu::get_accel_group()
{
  Glib::RefPtr<AccelGroup> retvalue = Glib::wrap(gtk_menu_get_accel_group(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const AccelGroup> Menu::get_accel_group() const
{
  return const_cast<Menu*>(this)->get_accel_group();
}

void Menu::set_accel_path(const Glib::ustring& accel_path)
{
  gtk_menu_set_accel_path(gobj(), accel_path.c_str());
}

Glib::ustring Menu::get_accel_path() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(gtk_menu_get_accel_path(const_cast<GtkMenu*>(gobj())));
}

void Menu::detach()
{
  gtk_menu_detach(gobj());
}

Widget* Menu::get_attach_widget()
{
  return Glib::wrap(gtk_menu_get_attach_widget(gobj()));
}

const Widget* Menu::get_attach_widget() const
{
  return const_cast<Menu*>(this)->get_attach_widget();
}

#ifndef GTKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
void Menu::set_tearoff_state(bool torn_off)
{
  gtk_menu_set_tearoff_state(gobj(), static_cast<int>(torn_off));
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GTKMM_DISABLE_DEPRECATED

#ifndef GTKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
bool Menu::get_tearoff_state() const
{
  return gtk_menu_get_tearoff_state(const_cast<GtkMenu*>(gobj()));
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GTKMM_DISABLE_DEPRECATED

#ifndef GTKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
void Menu::set_title(const Glib::ustring& title)
{
  gtk_menu_set_title(gobj(), title.c_str());
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GTKMM_DISABLE_DEPRECATED

#ifndef GTKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
Glib::ustring Menu::get_title() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(gtk_menu_get_title(const_cast<GtkMenu*>(gobj())));
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GTKMM_DISABLE_DEPRECATED

void Menu::set_screen(const Glib::RefPtr<Gdk::Screen>& screen)
{
  gtk_menu_set_screen(gobj(), Glib::unwrap(screen));
}

void Menu::attach(Gtk::Widget& child, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach)
{
  gtk_menu_attach(gobj(), (child).gobj(), left_attach, right_attach, top_attach, bottom_attach);
}

void Menu::set_monitor(int monitor_num)
{
  gtk_menu_set_monitor(gobj(), monitor_num);
}

int Menu::get_monitor() const
{
  return gtk_menu_get_monitor(const_cast<GtkMenu*>(gobj()));
}

void Menu::set_reserve_toggle_size(bool reserve_toggle_size)
{
  gtk_menu_set_reserve_toggle_size(gobj(), static_cast<int>(reserve_toggle_size));
}

bool Menu::get_reserve_toggle_size() const
{
  return gtk_menu_get_reserve_toggle_size(const_cast<GtkMenu*>(gobj()));
}

void Menu::attach_to_widget(Widget& attach_widget, GtkMenuDetachFunc detacher)
{
  gtk_menu_attach_to_widget(gobj(), (attach_widget).gobj(), detacher);
}


Glib::SignalProxy< void,const Gdk::Rectangle*,const Gdk::Rectangle*,bool,bool > Menu::signal_popped_up()
{
  return Glib::SignalProxy< void,const Gdk::Rectangle*,const Gdk::Rectangle*,bool,bool >(this, &Menu_signal_popped_up_info);
}


Glib::PropertyProxy< int > Menu::property_active() 
{
  return Glib::PropertyProxy< int >(this, "active");
}

Glib::PropertyProxy_ReadOnly< int > Menu::property_active() const
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "active");
}

Glib::PropertyProxy< Glib::RefPtr<AccelGroup> > Menu::property_accel_group() 
{
  return Glib::PropertyProxy< Glib::RefPtr<AccelGroup> >(this, "accel-group");
}

Glib::PropertyProxy_ReadOnly< Glib::RefPtr<AccelGroup> > Menu::property_accel_group() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<AccelGroup> >(this, "accel-group");
}

Glib::PropertyProxy< Glib::ustring > Menu::property_accel_path() 
{
  return Glib::PropertyProxy< Glib::ustring >(this, "accel-path");
}

Glib::PropertyProxy_ReadOnly< Glib::ustring > Menu::property_accel_path() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::ustring >(this, "accel-path");
}

Glib::PropertyProxy< Widget* > Menu::property_attach_widget() 
{
  return Glib::PropertyProxy< Widget* >(this, "attach-widget");
}

Glib::PropertyProxy_ReadOnly< Widget* > Menu::property_attach_widget() const
{
  return Glib::PropertyProxy_ReadOnly< Widget* >(this, "attach-widget");
}

#ifndef GTKMM_DISABLE_DEPRECATED

Glib::PropertyProxy< Glib::ustring > Menu::property_tearoff_title() 
{
  return Glib::PropertyProxy< Glib::ustring >(this, "tearoff-title");
}
#endif // GTKMM_DISABLE_DEPRECATED


#ifndef GTKMM_DISABLE_DEPRECATED

Glib::PropertyProxy_ReadOnly< Glib::ustring > Menu::property_tearoff_title() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::ustring >(this, "tearoff-title");
}
#endif // GTKMM_DISABLE_DEPRECATED


#ifndef GTKMM_DISABLE_DEPRECATED

Glib::PropertyProxy< bool > Menu::property_tearoff_state() 
{
  return Glib::PropertyProxy< bool >(this, "tearoff-state");
}
#endif // GTKMM_DISABLE_DEPRECATED


#ifndef GTKMM_DISABLE_DEPRECATED

Glib::PropertyProxy_ReadOnly< bool > Menu::property_tearoff_state() const
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "tearoff-state");
}
#endif // GTKMM_DISABLE_DEPRECATED


Glib::PropertyProxy< int > Menu::property_monitor() 
{
  return Glib::PropertyProxy< int >(this, "monitor");
}

Glib::PropertyProxy_ReadOnly< int > Menu::property_monitor() const
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "monitor");
}

Glib::PropertyProxy< bool > Menu::property_reserve_toggle_size() 
{
  return Glib::PropertyProxy< bool >(this, "reserve-toggle-size");
}

Glib::PropertyProxy_ReadOnly< bool > Menu::property_reserve_toggle_size() const
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "reserve-toggle-size");
}

Glib::PropertyProxy< Gdk::AnchorHints > Menu::property_anchor_hints() 
{
  return Glib::PropertyProxy< Gdk::AnchorHints >(this, "anchor-hints");
}

Glib::PropertyProxy_ReadOnly< Gdk::AnchorHints > Menu::property_anchor_hints() const
{
  return Glib::PropertyProxy_ReadOnly< Gdk::AnchorHints >(this, "anchor-hints");
}

Glib::PropertyProxy< int > Menu::property_rect_anchor_dx() 
{
  return Glib::PropertyProxy< int >(this, "rect-anchor-dx");
}

Glib::PropertyProxy_ReadOnly< int > Menu::property_rect_anchor_dx() const
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "rect-anchor-dx");
}

Glib::PropertyProxy< int > Menu::property_rect_anchor_dy() 
{
  return Glib::PropertyProxy< int >(this, "rect-anchor-dy");
}

Glib::PropertyProxy_ReadOnly< int > Menu::property_rect_anchor_dy() const
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "rect-anchor-dy");
}

Glib::PropertyProxy< Gdk::WindowTypeHint > Menu::property_menu_type_hint() 
{
  return Glib::PropertyProxy< Gdk::WindowTypeHint >(this, "menu-type-hint");
}

Glib::PropertyProxy_ReadOnly< Gdk::WindowTypeHint > Menu::property_menu_type_hint() const
{
  return Glib::PropertyProxy_ReadOnly< Gdk::WindowTypeHint >(this, "menu-type-hint");
}


} // namespace Gtk


